/***
* Name: TOYscale
* Author: David Alvarez Castro
* Description: 
* Tags: Tag1, Tag2, TagN
***/

model ABM_EPIDEMIC_TRANSMISSION_IN_NEWCASTLE_UNIVERSITY_STUDENTS





global {

	int simulation_repetition <- 1;  // value to identify the number of simulations done in this experiment.
	
	int nb_contaminated_elements <- 0;  // initialize the number of contaminated elements generated by Students and Dynamics.
	
	int nb_static_duplicate <- 0;  // initialize the number of duplicate static agent generated when becomes susceptible again.
		
	//DEFINITION OF THE GIS SHP FILES TO BE USED IN THE ABM:
    file shape_file_buildings <- file("../includes/buildings_with_interactions.shp");
    file shape_file_buildings_no_interaction <- file("../includes/buildings_no_interactions.shp");
    file shape_file_sidewalks <- file("../includes/footpaths.shp");
	file shape_file_students <- file("../includes/students.shp");
    file shape_file_bounds <- file("../includes/project_scale_boundary.shp");
    file shape_file_dynamics <- file("../includes/dynamics.shp");
    file shape_file_statics <- file("../includes/statics.shp");
    
    geometry shape <- envelope(shape_file_bounds);
    
    
    
    float step <- 1 #mn;  //the duration of a simulation step
    
    
    // Initialise the date and hour of the simulation
    int year <- 2020;
   	int month <- 3;
   	int day <- 14;
   	int hour <- 7;
   	int min <- 0;
   	int second <- 0; 
    date starting_date <- date([year,month,day,hour,min,second]);  //correspond the 14th of March 2020, at 06:00:00
    
    int day_of_year;   //value to initialize in the monitors the day to 'day 1'
    
    //DEFINE A GRAPH
    graph sidewalks_network;
    
    

	//INITIALISE THE SPECIES
    init {	
    	
    	//value to initialize in the monitors the day to 'day 1'
    	day_of_year <- current_date.day_of_year;
    	
    	//Create agents based on shapefiles and initialise some variables:	
		create buildings from: shape_file_buildings;
		
		create buildings_without_interaction from: shape_file_buildings_no_interaction;
		
		create background from: shape_file_bounds;
			
        create sidewalks from: shape_file_sidewalks ;
        sidewalks_network <- as_edge_graph(sidewalks);
        
        create students from: shape_file_students;
        
        //update the agents that have been randomly selected as infected.
        ask students_I_initial among students{
			is_infected <- true;
			is_susceptible <- false;
			infected_by <- 'zero-patient';  // categorise the agent as zero-patient
			infected_x <- home_geom_CRS_x;
			infected_y <- home_geom_CRS_y;
			infected_z <- home_geom_CRS_z;
			exposed_minute <- current_date.minute_of_day;
			exposed_day <- current_date.day_of_year;
			infective_minute <- current_date.minute_of_day;
            infective_day <- current_date.day_of_year;
            
    	}
        
        
        create dynamics from: shape_file_dynamics;
        
         ask dynamics_I_initial among dynamics{
			is_infected <- true;
			is_susceptible <- false;
			infected_by <- 'zero-patient';  // categorise the agent as zero-patient
			infected_x <- home_geom_CRS_x;
			infected_y <- home_geom_CRS_y;
			infected_z <- home_geom_CRS_z;
			exposed_minute <- current_date.minute_of_day;
			exposed_day <- current_date.day_of_year;
			infective_minute <- current_date.minute_of_day;
            infective_day <- current_date.day_of_year; 
    	}
        
        
        create statics from: shape_file_statics; 
        
         ask statics_I_initial among statics{
			is_infected <- true;
			is_susceptible <- false;
			infected_by <- 'zero-patient';  // categorise the agent as zero-patient
			infected_x <- home_geom_CRS_x;
			infected_y <- home_geom_CRS_y;
			infected_z <- home_geom_CRS_z;
			exposed_minute <- current_date.minute_of_day;
			exposed_day <- current_date.day_of_year;
			infective_minute <- current_date.minute_of_day;
            infective_day <- current_date.day_of_year; 
    	}  
    }
    


	int total_students -> length(students);
		

	//get the number of students exposed (nb_E_students), infected (nb_I_students), recovered (nb_R_students) and suscetible (nb_S_students) at the beginning of the simulation:
	// nb_S_agents, nb_E_agents, nb_I_agents and nb_R_agents values are updated every cycle of the simulation
	int students_E_initial <- 0;
	int nb_E_students <- students_E_initial update: students count (each.is_exposed);
	
	int students_I_initial <- 2;
	int nb_I_students <- students_I_initial update: students count (each.is_infected ); 
		
	int students_R_initial <- 0;
	int nb_R_students <- students_R_initial update: students count (each.is_recovered);
	
	int nb_S_students -> total_students - nb_E_students - nb_I_students - nb_R_students;
    
    

    int total_dynamics -> (length(dynamics));
	
	//get the number of dynamics exposed (nb_E_dynamics), infected (nb_I_dynamics), recovered (nb_R_dynamics) and suscetible (nb_S_dynamics) at the beginning of the simulation:
	// nb_S_agents, nb_E_agents, nb_I_agents and nb_R_agents values are updated every cycle of the simulation
	int dynamics_E_initial <- 0;
	int nb_E_dynamics <- dynamics_E_initial update: dynamics count (each.is_exposed);
	
	int dynamics_I_initial <- 0;
	int nb_I_dynamics <- dynamics_I_initial update: dynamics count (each.is_infected); 
	
	int dynamics_R_initial <- 0;
	int nb_R_dynamics <- dynamics_R_initial update: dynamics count (each.is_recovered);
	
	int nb_S_dynamics -> total_dynamics - nb_E_dynamics - nb_I_dynamics - nb_R_dynamics;
    
    
    
    int total_statics -> (statics count (each.name != 'Static_contaminated_object' ));
	
	int statics_I_initial <- 0;
	int nb_I_statics <- statics_I_initial update: statics count (each.is_infected and each.name != 'Static_contaminated_object'); 
		
	int nb_S_statics -> total_statics - nb_I_statics;
    
    
    // NUmber of contaminated elements:
    int contaminated_elements <- 0 update: statics count(each.name = "Static_contaminated_object");



    // Day of the year to be exported in the "BM_SIR_values_per_day.csv"
    int day_of_simulation <- current_date.day_of_year update: current_date.day_of_year - (day_of_year - 1);	    



    //INITIAL EPIDEMIOLOGICAL PARAMETERS:
    float beta_indoor <- 0.025;  //infection rate
    float beta_outdoor <- 0.005;  //infection rate
    int ro <- 5;     //incubation rate (days)
	int gamma <- 7;  //recovery rate (days)
	
	// probability value to create contaminated objects randomly when a person (student or dynamic agent) is infected.
    float contaminated_object_probability <- 0.001;
    
    
    //FACE MASKS PARAMETERS
    // Percentage of people (students and dynamics) using face mask 
    int percentage_people_with_mask <- 100;
    // First day to start using face masks in the simulation
    int first_day_with_mask <- 1;
    // Percentage of mask efficiency to reduce the risk to be infected. 
    int percentage_mask_efficiency <- 50;
    
    
    //LOCKDOWN PARAMETERS
    // First day to apply lockdown
    int first_day_lockdown <- 15;
    // Percentage of students doing lockdown
    int percentage_students_lockdown <- 40;
    
    
    //RESPONSIBLE PARAMETERS
    // First day to apply responsible people
    int first_day_responsible <- 10;
    // Percentage of people being responsible
    int percentage_people_responsible <-80;
    
    
    
    
    // Get in a list the % of students that will wear the face masks
    int students_with_facemask -> (round(total_students * (percentage_people_with_mask/100)));
    list<students> students_with_mask -> students_with_facemask among students;
    // Get in a list the % of students that will wear the face masks
    int dynamics_with_facemask -> (round(total_dynamics * (percentage_people_with_mask/100)));
    list<dynamics> dynamics_with_mask -> dynamics_with_facemask among dynamics;
    
    
    // Identify the people (students and dynamics) using face masks and update the "people_mask_efficiency" based on the "mask_efficiency" value provided by the user.
    reflex face_mask_use when: (day_of_simulation = first_day_with_mask) and current_date.minute_of_day = 450{

    	// Select x percentage of students and assign them the efficiency of face masks set up from the user
    	 ask students_with_mask{
    	 	people_mask_efficiency <- percentage_mask_efficiency;
    	 	is_using_facemask <- true;
    	 	
    	 }
    	 // Select x percentage of dynamics and assign them the efficiency of face masks set up from the user
    	 ask dynamics_with_mask{
    	 	people_mask_efficiency <- percentage_mask_efficiency;
    	 	is_using_facemask <- true;
    	 }
    }
    
    

    // Get in a list the % of students that will be in lockdown
    int students_in_lockdown -> (round(total_students * (percentage_students_lockdown/100)));
    list<students> students_in_lockdown_list -> students_in_lockdown among students;
    
    reflex lockdown when: (day_of_simulation = first_day_lockdown) and (current_date.minute_of_day = 450){
		ask students_in_lockdown_list{
			// When in_lockdown <- true, these students will stay at home. Reflex related to movements in the area of students are going to be
			// triggered if bool "in_lockdown" value is false only.
			in_lockdown <- true;
			
			//This reflex is triggered at 7:30 (minute 450). This means the students are already at home, so there is no need to tell them to go home.
			//In the case that at 7:30am students are anywhere else, then the folloging commented line should be un-commented, in order to let them go home.
			
			//do goto target: home_geom speed: speed_to_task;
		}
	}
    
    
	//Default paths and file names for the output files:
    string file_ABM_SIR_values_per_day <- "../results/ABM_SEIR_values_per_day.csv";
    string val_SEIR <- "ABM_SEIR_values_per_day";
    string file_Agents_after_simulation <- "../results/Agents_after_simulation.csv";
    string val_Agents <- "Agents_after_simulation";
    string file_transmission_list <- "../results/Transmission_list_.csv";
    string val_transmission_list <- "Transmission_list_";
    string file_txt <- "../results/Initial_data_and_parameters.txt";
    string val_txt <- "Initial_data_and_parameters";
    

    // OUTPUT-FILE NAMES VALIDATION. Validates if outputs files already exist at the beginning of the simulation (simulation cycle = 1):
    reflex check_file_names when: cycle = 1{
    	//Check if the file containing the SEIR values per day with the default name is already created. If so, a new one is requested to the user:
		loop while: file_exists(file_ABM_SIR_values_per_day){
			write "File " + val_SEIR + " already exist!";
			map users_file_ABM_SIR_values_per_day <- user_input ("File " + val_SEIR + " already exist!" + "\nProvide a new name for the file", ["Name" :: "new name"]);
			val_SEIR <- string(users_file_ABM_SIR_values_per_day at "Name");
			file_ABM_SIR_values_per_day <- ("../results/" + val_SEIR + ".csv");
			write file_ABM_SIR_values_per_day;
		}
		//Check if the file containing the Agent's status when simulation is finised with the default name is already created. If so, a new one is requested to the user:
		loop while: file_exists(file_Agents_after_simulation){
			write "File " + val_Agents + " already exist!";
			map users_file_Agents_after_simulation <- user_input ("File " + val_Agents + " already exist!" + "\nProvide a new name for the file", ["Name" :: "new name"]);
			val_Agents <- string(users_file_Agents_after_simulation at "Name");
			file_Agents_after_simulation <- ("../results/" + val_Agents + ".csv");
			write file_Agents_after_simulation;
		}
		//Check if the file containing the Adjacency list values with the default name is already created. If so, a new one is requested to the user:
		loop while: file_exists(file_transmission_list){
			write "File " + val_transmission_list + " already exist!";
			map users_file_file_adjacency_list <- user_input ("File " + val_transmission_list + " already exist!" + "\nProvide a new name for file", ["Name" :: "new name"]);
			val_transmission_list <- string(users_file_file_adjacency_list at "Name");
			file_transmission_list <- ("../results/" + val_transmission_list + ".csv");
			write file_transmission_list;
		}
		//Check if the file containing the Initial data and parameters with the default name is already created. If so, a new one is requested to the user:
		loop while: file_exists(file_txt){
			write "File " + val_txt + " already exist!";
			map users_file_txt <- user_input ("File " + val_txt + " already exist!" + "\nProvide a new name for the file", ["Name" :: "new name"]);
			val_txt <- string(users_file_txt at "Name");
			file_txt <- ("../results/" + val_txt + ".csv");
			write file_txt;
		}
    }
    
    
    //Save the SIER values, number of contaminated elements and Rvalue, every day of the simulation when the cycle is equals to 450 (07:30 am)
	reflex ABM_SIER_values_per_day when: current_date.minute_of_day = 450{
		//save the values of the variables day_of_week, nb_S_agents, nb_E_agents, nb_I_agents, nb_R_agents and R to the csv file; 
		//the rewrite facet is set to false to continue to write in the same file
		save [day_of_simulation, nb_S_students, nb_E_students, nb_I_students, nb_R_students, contaminated_elements] 
		to: file_ABM_SIR_values_per_day type:"csv" rewrite: false;
	}
	
	
	//Pause the simulation when Exposed and Infected people are 0. Then export 2 csv files (Agents_simulation_end.csv and Agents_adjacency_list.csv).
	reflex save_agents_csv when: (nb_E_students = 0 and  nb_I_students = 0){
		do pause;
		// Save the evolution in time of the disease (SEIR graph) and the transmission of the disease between students in csv files
		ask students {
			
			save[id, name, type, t1_even, t2_even, t3_even, t4_even, t1_odd, t2_odd, t3_odd, t4_odd, is_susceptible, is_exposed, 
				is_infected, is_recovered, infective_contact_counter, infected_x, infected_y, infected_z, exposed_minute, exposed_day, 
				infected_by, infective_day, infective_minute] to: file_Agents_after_simulation type:"csv" rewrite: false;
			
			save[id, type, infected_by,  infected_x, infected_y, exposed_day, exposed_minute] to: file_transmission_list type:"csv" rewrite: false;
			
		}
		//save the transmission of the disease between dynamics in a csv file (in the same where students were saved).
		ask dynamics {
			save[id, type, infected_by,  infected_x, infected_y, exposed_day, exposed_minute] to: file_transmission_list type:"csv" rewrite: false;
		}
		//save the transmission of the disease between statics in a csv file (in the same where students and dynamics were saved). 
		ask statics {
			save[id, type, infected_by,  infected_x, infected_y, exposed_day, exposed_minute] to: file_transmission_list type:"csv" rewrite: false;
		}
		
		
		// Save a txt file containing the input data; date and hour set for the simulation; and epidemiological parameters set at the beginning of the simulation.
		save ("***#####################################################################################################***" +
				"\nFILE CONTAINING THE GIS INPUT DATA, DATE-HOUR AND EPIDEMIOLOGICAL PARAMETERS SET FOR THE SIMULATION" +
				"\n\nInput GIS Data:" +  
				"\n-Buildings: " + shape_file_buildings + 
				"\n-Buildings without interaction: " + shape_file_buildings_no_interaction +
				"\n-Students: " + shape_file_students + 
				"\n-Dynamics: " + shape_file_dynamics +
				"\n-Statics: " + shape_file_statics +
				"\n-Sidewalks: " + shape_file_sidewalks +
				"\n-Boundary polygon: " + shape_file_bounds + 
				"\n\nInitial date and hour for the simulation: " + starting_date +
				"\n\nEpidemiological Parameters: " + 
				"\n-Probability to be infected indoor (beta indoor): " + beta_indoor + 
				"\n-Probability to be infected outdoor(beta outdoor): " + beta_outdoor + 
				"\n-Incubation period (ro): " + ro + " days" + 
				"\n-Contagious period (gamma): " + gamma + " days" +
				"\n-Initial number of Infective students: " + students_I_initial +
				"\n-Initial number of Infective dynamics: " + dynamics_I_initial +
				"\n-Initial number of Infective statics: " + statics_I_initial + 
				"\n\nFace mask parameters:" +  
				"\n-Percentage of agents (students and dynamics) using face mask: " + percentage_people_with_mask + 
				"\n-First day using face mask: " + first_day_with_mask + 
				"\n-Percentage face mask efficiency: " + percentage_mask_efficiency + 
				"\n\nLockdown parameters:" +
				"\n-First day in lockdown: " + first_day_lockdown +
				"\n-% of students in lockdown: " + percentage_students_lockdown +
				"\n\nResponsability parameters:" + 
				"\n-First day self isolation: " + first_day_responsible +
				"\n-% of students doing self isolation: " + percentage_people_responsible +
				"\n\n***#####################################################################################################***\n\n") 
			to: file_txt rewrite: false;
		
		//Write a message alerting the user that the simulation has been finished.
		write 'Simulation has finished!!' color: #red;
		write 'The disease has been removed from the environment' color: #red;
	}
	
	
	

	//Allow random movement of STUDENTS inside buildings when current time in minutes is between 510 (8:30am) and 1230 (20:30pm)
    reflex random_move_inside_buildings_students when: current_date.minute_of_day between(510, 1230){
    	ask buildings{
    		ask students {
				// If the students agents are inside a building 
				//then the students agents move randomly inside the buildings at a specific speeds depending on the building's type.
				if(self overlaps myself){
					do wander speed: (myself.bui_speed) bounds:(myself.shape) amplitude: 20.0;
					//If building is outdoors (parks) then beta value should be beta_outdoor. If not, then beta values is beta_indoor
					if myself.name = 'Park1' or myself.name = 'Park2' or myself.name = 'Park3' or myself.name = 'Park4' or
    				myself.name = 'Park5' or myself.name = 'Park6' or myself.name = 'Park7' or myself.name = 'Park8'{
						beta <- beta_outdoor;
    				}else{
						beta <- beta_indoor;
    				}  					
				}
    		}
    	}
    }
    

	// Reflex to move randomly the dynamic agents inside the buildings when current time in minutes is between 510 (8:30am) and 1230 (20:30pm)
    reflex random_move_inside_buildings_dynamics when: current_date.minute_of_day between(510, 1230) 
    	{
    	ask buildings{
    		ask dynamics {
				// If the students and dynamic agents are inside a building 
				//then the students and dynamic agents move randomly inside the buildings at a specific speeds depending on the building's type.
				if(self overlaps myself){
					do wander speed: (myself.bui_speed) bounds:(myself.shape) amplitude: 20.0;
					//If building is outdoors (parks) then beta value should be beta_outdoor. If not, then beta values is beta_indoor
					if myself.name = 'Park1' or myself.name = 'Park2' or myself.name = 'Park3' or myself.name = 'Park4' or
    				myself.name = 'Park5' or myself.name = 'Park6' or myself.name = 'Park7' or myself.name = 'Park8'{
						beta <- beta_outdoor;
    				}else{
						beta <- beta_indoor;
    				}
				}
    		}
    	}
    }
}





/*** DEFINE THE SPECIES:  ***/

//Define attributes for buildings:
species buildings{
	//int id;
	//string name;
	string type;
	
	//buildings floors and heights values
	int bui_floor;
	int buildings_height <- (bui_floor * 4) + 4;  //height of each building based on the number of floors + the height of the last floor.
	
	// color depending on the type attribute
	//rgb color <- type ="faculties" ? #blue : ((type ="gyms") ? #red: ((type ="leasure") ? #green: ((type ="library") ? #purple: 
			//((type ="residences") ? #grey: ((type ="supermarke") ? #orange: #yellow)))));
	
	// variable with the different speed values depending on the type of building.
	float bui_speed ;
	
	// Aspect of the buildings in the simulation:
    aspect base {
        draw shape color: #orange depth: buildings_height;
    }
    
}

// Buildings that DO NOT interact with the students (they are just for a visualisation purpose)
species buildings_without_interaction{
	
	//buildings floors and heights values
	int bui_floor;
	int buildings_height <- (bui_floor * 4) + 4;  //height of each building based on the number of floors + the height of the last floor.
	
	aspect base {
        draw shape color: #grey depth: buildings_height;
    }
}


//Define attributes for the sidewalks:
species sidewalks  {
    
    rgb color <- #grey + 100 ;
    aspect base {
        draw shape color: color ;
    }
}





species agents_with_epidemic_interactions {
	
	init{
			// locate the agentes with the correct height value at the begining of tht simulation. 
			// If this is not done, z = 0 always (because of the coord. transformation??)
			location <- {location.x, location.y, init_height};  
	    	
	    	//Save the original location as 'home'
	    	if(home_geom = nil){
				home_geom <- location;  // Save the exact location where each agent starts the simulation.
			}
		
			geometry home_geom_CRS <- {home_geom.x, home_geom.y, home_geom.z}  CRS_transform("EPSG:27700");
			
			home_geom_CRS_x <- home_geom_CRS.location.x;
			home_geom_CRS_y <- home_geom_CRS.location.y;
			home_geom_CRS_z <- home_geom_CRS.location.z;
		
	}
	
	
	float beta <- beta_indoor;
	
	
	string type;
	
	// this value refers the residence's floor where the student is living.
   	int init_floor;
   	// this is to locate the student in the correct height.
   	float init_height <- float(init_floor * 4);
   	
	string objective ; //this variable allows to have a value to change the task to be done
	
	point home_geom;  //get the location where each 'people' starts the simulation ('this is like the room where they live for the students').
	
	geometry home_CRS;
	
	float home_geom_CRS_x;
	float home_geom_CRS_y;
	float home_geom_CRS_z;
	
	
    //this target is initiallised to nil and when objective and cycle are equal to specific values, 
    //then there is a target and the student starts moving to that place
    point the_target <- nil ;  
    

    //Epidemiology variables:
    bool is_susceptible <- true;
    bool is_exposed <- false;
    bool is_infected <- false;
    bool is_recovered <- false;
    bool is_extintct <- false; //This variable is to disable contaminated elements and keep the record in the simulation to be analysed in the transmission output
    bool not_in_use <- false; //this variable is used to disable static elements after infecting an agent (student or dynamic) and generate a new static element in the same location
    
    string infected_by;
    
    // integer value to count the number of times each agent is in close contact with an infective and can be infected.
    int infective_contact_counter <- 0;
    
    // local coordinates where each agent is infected
    float infected_x_local;  
    float infected_y_local;
    float infected_z_local;
   	
   	//EPSG 27700 coordinates where each agent is infected
   	float infected_x;
   	float infected_y;
   	float infected_z;
   	
   	
   	int exposed_minute;
    int exposed_day;
   	
   	// minute in which each agent becomes infective (can infect others)
   	int infective_minute;
   	// day of the year in which each agent becomes infective (can infect others)
   	int infective_day;
    
    
    
    //location where the contaminated product is generated
    float product_infected_x;
    float product_infected_y;
    float product_infected_z;
    
    
    
    int people_mask_efficiency <- 0;
    bool is_using_facemask <- false;
    
    
       
    aspect sphere3D{
    	// sphere (radius)
    	draw sphere(1) at: {location.x,location.y,location.z} color: (is_susceptible ? #green :  // if it is susceptible, then it is green.
    		((is_exposed) ? #orange :						// if it is exposed, then is orange.
    		((is_infected) ? #red:                       	// if it is infected, then it is red.
    		((is_recovered) ? #blue: 						// if it is recoverd, then is blue.
    		((is_extintct) ? #transparent:					// if it is extinct, then is transparent.
    		((not_in_use) ? #transparent:	#black			// if it is not_in_use, then is transparent as well, else is black.
    		))))));		
    	

    	
    	draw circle(2) at: {product_infected_x,product_infected_y, product_infected_z + 0.5} color: #orange border: #grey;  // location where contaminated product is created!!	
    	
    	draw circle(1.7) at: {infected_x_local,infected_y_local, infected_z_local + 0.7} color: #yellow border: #grey;  // location where each student or dynamic agent has been infected!!	

		draw circle (1.6) at: {location.x,location.y,location.z + 0.5} color: is_using_facemask ? #purple: #transparent;  //Identify which students and dynamic agents are using facemask

    }
    

    
}





species statics parent: agents_with_epidemic_interactions{
	
	
	//string located; //variable giving the name of the building where it is located.
	
	string id;
	string name <- id;
	string type <- 'Static';
	

	init{
		
    	// locate the agentes with the correct height value at the begining of tht simulation. 
		// If this is not done, z = 0 always (because of the coord. transformation??)
		location <- {location.x, location.y, init_height};  
        
	}
	
	// When a static agent is infected by a student or dynamic, this action is triggered in a reflex related to students or dyamics (depends on who is the infective agent).
	action S_to_I_statics {
    	is_infected <- true;
        is_susceptible <- false;    	
    	//local coordinates where agent was infected 
    	infected_x_local <- self.location.x;
    	infected_y_local <- self.location.y;
    	infected_z_local <- self.location.z;
    	//generate a geometry in the correct EPSG code (27700)
    	geometry var1 <- {infected_x_local, infected_y_local, self.location.z}  CRS_transform("EPSG:27700");
    	//coordinates where agents where infected in the EPSG 27700
    	infected_x <- var1.location.x;
    	infected_y <- var1.location.y;
    	infected_z <- var1.location.z;
    	// gives the minute of the day in which the agent was infected
    	infective_minute <- current_date.minute_of_day;
    	infective_day <- current_date.day_of_year;
    }
	
	
	
	// A Static agent infects a student. After that the Static agent becomes susceptible again!
    reflex from_S_to_E_statics_to_students when: is_infected{
        ask students at_distance 2 #m {
        	if (self.is_susceptible){
        		self.infective_contact_counter <- self.infective_contact_counter + 1;
        		if flip(myself.beta * (1 - (self.people_mask_efficiency/100))) {
	                self.infected_by <- myself.id; 
	                do S_to_E_students;
	                
	                // change on the status of the static agent
	               	myself.is_infected <- false;
	               	myself.is_extintct <- true;
            	}
        	}
            
        }
    }
    
    
    // A Static agent infects a dynamic. After that the Static agent becomes susceptible again!
    reflex from_S_to_E_statics_to_dynamics when: is_infected{
        ask dynamics at_distance 2 #m {
        	if (self.is_susceptible){
        		self.infective_contact_counter <- self.infective_contact_counter + 1;
        		if flip(myself.beta * (1 - (self.people_mask_efficiency/100)))  {
	                self.infected_by <- myself.id; 
	                do S_to_E_dynamics;
	                
	                // change on the status of the static agent
	                myself.is_infected <- false;
	                myself.is_extintct <- true;  
            	}
        	}
        }
    }
    

	// When a static agent has infected an agent (student or dynamic) then its status is 'extinct' and moved to 'not in use'. 
	// Once this happens, a new static agent is created in the same places, with same characteristics but with empty attributes.
	// This allows to keep tracking of the transmission of the disease. If this is not done, then only the last agent (student or dynamic) who infected the
	// static agent is recorded, loosing the previous ones. Having a new agent, all these transmissions are kept in the model and saved in the transmission csv file as an output.
	reflex static_extinct_to_NotInUse_and_reproduce_a_new_static_in_the_same_place when: (is_extintct and name != 'Static_contaminated_object'){
		self.is_extintct <- false;
		self.not_in_use <- true;
		
		// create a new static agent in the same place AND with a different id value. With this, the transmission of the disease can be tracked easier than keeping the same
		// static agent (if so, it is only kept the last agent (student or dynamic) that infect the static agent).
		create species(statics) number: 1{
            location <- {myself.location.x, myself.location.y, myself.location.z};
            type <- 'Static';
            nb_static_duplicate <- nb_static_duplicate + 1;
            id <- myself.id + '_' + nb_static_duplicate;
            name <- id;
            
            // re-set the epidemiological states
            is_susceptible <- true;
            is_exposed <- false;
            is_infected <- false;
            is_recovered <- false;
            is_extintct <- false;
            not_in_use <- false;
        }
		
	}
	
	
	
	
	// STATIC NON CONTAMINATED ELEMENTS ONLY:
	// value to get the lifetime of the infected Static agent. After this time, they become susceptible again
	int infected_static_lifetime <- rnd(0, 1439);
	
	// static agents have a lifetime between 0 and 1440 minutes (from 0min to 1 day). After that time, they become AGAIN susceptible.
	reflex from_I_to_S_statics when: is_infected and (name != 'Static_contaminated_object') and (current_date.minute_of_day - infected_static_lifetime = 0) {
		self.is_susceptible <- true;
		self.is_infected <- false;
		self.is_extintct <- false;
	}
	
	
	
	// STATIC CONTAMINATED ELEMENTS ONLY:
	// value to get the lifetime of the infected contaminated object. After this time, they become 'extinct' and are displayed in transparent (do not interact anymore).
	int infected_contaminated_object_lifetime <-rnd(0, 1439);
    
    // Convert the contaminated object into 'Extinct' if has infected a Student or Dynamic (after this it becomes susceptible an should "die") or after "infected_contaminated_object_lifetime" time
	reflex remove_contaminated_object when: (is_infected and name = 'Static_contaminated_object' and current_date.minute_of_day - infected_contaminated_object_lifetime = 0){
		
		self.is_infected <- false;		// In case it was infected, it is not anymore
		self.is_susceptible <- false;  // In case it was susceptible, it is not anymore (it was susceptible because it had infected someone else before)
		self.is_extintct <- true;   // Now it is extinct (similar to dead but kept in the model in order to be analysed in the transmission output) 
		
		// From now one, each contaminated element that is extinct is displayed in the simulation as a transparent symbol, so it is not visible and does not interact with others.
		// They do not have any interaction.
	}
	

}





species dynamics skills:[moving] parent: agents_with_epidemic_interactions{
	
	
	
	init{
		
		// locate the agentes with the correct height value at the begining of tht simulation. 
		// If this is not done, z = 0 always (because of the coord. transformation??)
		location <- {location.x, location.y, init_height};  
        
	}
	
	//string located; //variable giving the name of the building where it is located.

	string id;
	string name <- id;
	string type <- 'Dynamic';
	
	// over-write the value. In this case, it is initialised to outdoor. In a reflex function it is checked if the dynamic agent is inside a building. 
	// If so, then beta value is equal to beta_indoor value.
	float beta <- beta_outdoor;
	
	
	bool is_responsible <- false;

	point home_basement;
	
	action S_to_E_dynamics {
    	is_exposed <- true;
        is_susceptible <- false;    	
    	//local coordinates where agent was infected 
    	infected_x_local <- self.location.x;
    	infected_y_local <- self.location.y;
    	infected_z_local <- self.location.z;
    	//generate a geometry in the correct EPSG code (27700)
    	geometry var1 <- {infected_x_local, infected_y_local, self.location.z}  CRS_transform("EPSG:27700");
    	//coordinates where agents where infected in the EPSG 27700
    	infected_x <- var1.location.x;
    	infected_y <- var1.location.y;
    	infected_z <- var1.location.z;
    	// gives the minute of the day in which the agent was infected
    	exposed_minute <- current_date.minute_of_day;
    	exposed_day <- current_date.day_of_year;
    }
    
    
    
    action contaminated_elements_dynamics{
    	
    	create species(statics) number: 1{
            location <- {myself.location.x, myself.location.y, myself.location.z};
            name <- 'Static_contaminated_object';
            type <- 'Static';
            nb_contaminated_elements <- nb_contaminated_elements + 1;
            id <- 'CE' + myself.id + '_' + nb_contaminated_elements;
            is_susceptible <- false;
            is_exposed <- false;
            is_infected <- true;
            is_recovered <- false;
            infective_minute <- current_date.minute_of_day;
            infective_day <- current_date.day_of_year (day_of_year-1);
            infected_by <- myself.id;
            //local coordinates where agent was infected 
            product_infected_x <- myself.location.x;
            product_infected_y <- myself.location.y;
            product_infected_z <- myself.location.z;
	    	//generate a geometry in the correct EPSG code (27700)
	    	geometry var2 <- {product_infected_x, product_infected_y, product_infected_z}  CRS_transform("EPSG:27700");
	    	//coordinates where agents where infected in the EPSG 27700
	    	infected_x <- var2.location.x;
	    	infected_y <- var2.location.y;
	    	infected_z <- var2.location.z;
            the_target <- nil;
        }
    }


    reflex from_S_to_E_dynamics_to_dynamics when: is_infected{
        ask dynamics at_distance 2 #m {
        	if (self.is_susceptible){
        		self.infective_contact_counter <- self.infective_contact_counter + 1;
        		if flip(myself.beta * (1 - (self.people_mask_efficiency/100)) * (1 - (myself.people_mask_efficiency/100))) {
	                self.infected_by <- myself.id; 
	                do S_to_E_dynamics;
            	}
        	}
        }
    }
    
    
    reflex from_S_to_E_dynamics_to_students when: is_infected{
        ask students at_distance 2 #m {
        	if (self.is_susceptible){
        		self.infective_contact_counter <- self.infective_contact_counter + 1;
        		if flip(myself.beta * (1 - (self.people_mask_efficiency/100)) * (1 - (myself.people_mask_efficiency/100)))  {
	                self.infected_by <- myself.id; 
	                do S_to_E_students;
            	}
        	}
        }
    }
    
    
    reflex from_S_to_E_dynamics_to_statics when: is_infected{
        ask statics at_distance 2 #m {
        	if (self.is_susceptible){
        		self.infective_contact_counter <- self.infective_contact_counter + 1;
        		if flip(myself.beta * (1 - (myself.people_mask_efficiency/100)))  {
	                self.infected_by <- myself.id;
	                do S_to_I_statics;
            	}
        	}
        }
    }
    
    // transform dynamics from Exposed to Infective once the incubation period (ro) has finished
    reflex from_E_to_I_dynamics when: is_exposed and (current_date.day_of_year - exposed_day = ro) and (current_date.minute_of_day - exposed_minute = 0){
    	is_infected <- true;
    	is_exposed <- false;
    	infective_minute <- current_date.minute_of_day;
        infective_day <- current_date.day_of_year;
        
        //If the dynamic is responsible, he/she will go home to be isolated (home_basement to be away from susceptible)
        if (day_of_simulation >= first_day_responsible){
        	if flip(percentage_people_responsible/100){
        		is_responsible <- true;
        		home_basement <- {home_geom.x, home_geom.y, -4};
        		location <- home_basement;
        	}
        }
	}
	
	// The dynamic is free to continue his/her life. From this point he/she will start doing the daily routines
	reflex resposible_recovered_dynamic when: is_responsible and is_recovered {
    	is_responsible <- false;
    	location <- home_geom;
    }
    
    
    //Generate some contaminated objects in the locating where an infected person is located, based on the probability value of contaminated_object_probability
	//https://gama-platform.github.io/wiki/PredatorPrey_step6
	reflex contaminated_objects_dynamics when: is_infected and flip(contaminated_object_probability) and (current_date.minute_of_day between(480, 1230) and (is_responsible = false)){
		do contaminated_elements_dynamics;
	}
	
	
	// Convert dynamics from infective to recovered.
    reflex from_I_to_R_dynamics when: is_infected and (current_date.day_of_year - infective_day = gamma) and (current_date.minute_of_day - infective_minute = 0) {
		is_infected <- false;
		is_recovered <- true;	
	}

}







species students skills:[moving] parent: agents_with_epidemic_interactions{


	init{
		
    	if even(day){
			objective <- "start_even_days";  //initialise objective to value 'start_the_day'. Objective value works as a condition in the code.
		}else{
			objective <- "start_odd_days";  //initialise objective to value 'start_the_day'. Objective value works as a condition in the code.
		}
    	
		
    	
	}


   	string residence;

    string id;
	string name <- id;
	string type <- 'Student';
	
	//TASKS AND TIMES FOR EVEN DAYS
	// varialbes with the tasks each student will do in even days
	string t1_even; //attribute that contains the name of the building where the student will go in task 1 in even days
	string t2_even; //attribute that contains the name of the building where the student will go in task 2 in even days
	string t3_even; //attribute that contains the name of the building where the student will go in task 3 in even days
	string t4_even; //attribute that contains the name of the building where the student will go in task 4 in even days
	// variables with the starting time of the tasks in even days
	int t1_t_even; // attribute that refers to the time when task 1 will start in even days
	int t2_t_even; // attribute that refers to the time when task 2 will start in even days
	int t3_t_even; // attribute that refers to the time when task 3 will start in even days
	int t4_t_even; // attribute that refers to the time when task 4 will start in even days
	int home_t_e;  // attribute that refers to the time when students will go home in even days at the end of the day
	
	
	//TASKS AND TIMES FOR ODD DAYS
	// varialbes with the tasks each student will do in odd days
	string t1_odd; //attribute that contains the name of the building where the student will go in task 1 in odd days
	string t2_odd; //attribute that contains the name of the building where the student will go in task 2 in odd days
	string t3_odd; //attribute that contains the name of the building where the student will go in task 3 in odd days
	string t4_odd; //attribute that contains the name of the building where the student will go in task 4 in odd days
	// variables with the starting time of the tasks in even days
	int t1_t_odd; // attribute that refers to the time when task 1 will start in odd days
	int t2_t_odd; // attribute that refers to the time when task 2 will start in odd days
	int t3_t_odd; // attribute that refers to the time when task 3 will start in odd days
	int t4_t_odd; // attribute that refers to the time when task 4 will start in odd days
	int home_t_o;  // attribute that refers to the time when students will go home in odd days at the end of the day
	

	// speed when in the sidewalks is a random value between 0.8 and 1.4 m/s for each student (3 - 5 km/h).
    float speed_to_task <- rnd(0.8, 1.4);  // Agents speed when moving between tasks. Random value between 0.8 and 1.4 m/s.

	bool in_lockdown <- false;
	
	bool is_responsible <- false;
	point home_basement;


	// REFLEX FOR TASKS IN EVEN DAYS

    // Action that allows the students to do the task 1 in even days
    //Based at the beginning in the following tutorial: https://gama-platform.github.io/wiki/RoadTrafficModel_step3
    reflex time_to_task1_even when: (even(current_date.day) and  (current_date.minute_of_day = t1_t_even) and (in_lockdown = false) and (is_responsible = false)){
    	objective <- "t1_even";
    	the_target <- any_point_in (one_of(buildings where (each.name=t1_even)));
    	
    	//allow the students to go to a random floor in the building
    	ask buildings{
    		if myself.t1_even = self.name{
    			if myself.t1_even = myself.residence{
    				myself.the_target <- myself.home_geom;
    			}else{
    				float the_target_z <-  float(rnd(0, self.bui_floor) * 4);
    				myself.the_target <- {myself.the_target.x, myself.the_target.y, the_target_z};
    			}
    		}
    	} 		
    }
    
     
    // Action that allows the students to do the task 2 in even days
    //Based at the beginning in the following tutorial: https://gama-platform.github.io/wiki/RoadTrafficModel_step3
    reflex time_to_task2_even when: (even(current_date.day) and (current_date.minute_of_day = t2_t_even) and (in_lockdown = false) and (is_responsible = false)){
    	objective <- "t2_even";
    	the_target <- any_point_in (one_of(buildings where (each.name=t2_even)));
    	
    	//allow the students to go to a random floor in the building
    	ask buildings{
    		if myself.t2_even = self.name{
    			if myself.t2_even = myself.residence{
    				myself.the_target <- myself.home_geom;
    			}else{
    				float the_target_z <-  float(rnd(0, self.bui_floor) * 4);
    				myself.the_target <- {myself.the_target.x, myself.the_target.y, the_target_z};
    			}
    		}
    	} 		
    }
    
    
    // Action that allows the students to do the task 3 in even days
    //Based at the beginning in the following tutorial: https://gama-platform.github.io/wiki/RoadTrafficModel_step3
    reflex time_to_task3_even when: (even(current_date.day) and (current_date.minute_of_day = t3_t_even) and (in_lockdown = false) and (is_responsible = false)){
    	objective <- "t3_even";
    	the_target <- any_point_in (one_of(buildings where (each.name=t3_even)));
    	
    	//allow the students to go to a random floor in the building
    	ask buildings{
    		if myself.t3_even = self.name{
    			if myself.t3_even = myself.residence{
    				myself.the_target <- myself.home_geom;
    			}else{
    				float the_target_z <-  float(rnd(0, self.bui_floor) * 4);
    				myself.the_target <- {myself.the_target.x, myself.the_target.y, the_target_z};
    			}
    		}
    	} 		
    }
    
    
    // Action that allows the students to do the task 4 in even days
    //Based at the beginning in the following tutorial: https://gama-platform.github.io/wiki/RoadTrafficModel_step3
    reflex time_to_task4_even when: (even(current_date.day) and (current_date.minute_of_day = t4_t_even) and (in_lockdown = false) and (is_responsible = false)){
    	objective <- "t4_even";
    	the_target <- any_point_in (one_of(buildings where (each.name=t4_even)));
    	
    	//allow the students to go to a random floor in the building
    	ask buildings{
    		if myself.t4_even = self.name{
    			if myself.t4_even = myself.residence{
    				myself.the_target <- myself.home_geom;
    			}else{
    				float the_target_z <-  float(rnd(0, self.bui_floor) * 4);
    				myself.the_target <- {myself.the_target.x, myself.the_target.y, the_target_z};
    			}
    		}
    	} 		
    }
    
    
    // Action that allows the students to go back home in even days
    //THANKS TO https://gama-platform.github.io/wiki/RoadTrafficModel_step3
    reflex time_to_home_even when: (even(current_date.day) and (current_date.minute_of_day = home_t_e) and (in_lockdown = false) and (is_responsible = false)){
    	the_target <- home_geom;
    	objective <- "start_odd_days" ;
    }
    
    
    
    // Reflex to reset the objective at the end of the day
    reflex reset_objective_midnight_even when: (even(current_date.day) and current_date.minute_of_day = 1430){
    	objective <- "start_odd_days";
    }
        
    
    
    // REFLEX FOR ODD DAYS
    
    // Action that allows the students to do the task 1 in odd days
    //Based at the beginning in the following tutorial: https://gama-platform.github.io/wiki/RoadTrafficModel_step3
    reflex time_to_task1_odd when: (not even(current_date.day) and  (current_date.minute_of_day = t1_t_odd) and (in_lockdown = false) and (is_responsible = false)){
    	objective <- "t1_odd";
    	the_target <- any_point_in (one_of(buildings where (each.name=t1_odd)));
    	
    	//allow the students to go to a random floor in the building
    	ask buildings{
    		if myself.t1_odd = self.name{
    			if myself.t1_odd = myself.residence{
    				myself.the_target <- myself.home_geom;
    			}else{
    				float the_target_z <-  float(rnd(0, self.bui_floor) * 4);
    				myself.the_target <- {myself.the_target.x, myself.the_target.y, the_target_z};
    			}
    		}
    	} 		
    }
    
    
    // Action that allows the students to do the task 2 in odd days
    //Based at the beginning in the following tutorial: https://gama-platform.github.io/wiki/RoadTrafficModel_step3
    reflex time_to_task2_odd when: (not even(current_date.day) and (current_date.minute_of_day = t2_t_odd) and (in_lockdown = false) and (is_responsible = false)){
    	objective <- "t2_odd";
    	the_target <- any_point_in (one_of(buildings where (each.name=t2_odd)));
    	
    	//allow the students to go to a random floor in the building
    	ask buildings{
    		if myself.t2_odd = self.name{
    			if myself.t2_odd = myself.residence{
    				myself.the_target <- myself.home_geom;
    			}else{
    				float the_target_z <-  float(rnd(0, self.bui_floor) * 4);
    				myself.the_target <- {myself.the_target.x, myself.the_target.y, the_target_z};
    			}
    		}
    	} 		
    }
    
    
    // Action that allows the students to do the task 3 in odd days
    //Based at the beginning in the following tutorial: https://gama-platform.github.io/wiki/RoadTrafficModel_step3
    reflex time_to_task3_odd when: (not even(current_date.day) and (current_date.minute_of_day = t3_t_odd) and (in_lockdown = false) and (is_responsible = false)){
    	objective <- "t3_odd";
    	the_target <- any_point_in (one_of(buildings where (each.name=t3_odd)));
    	
    	//allow the students to go to a random floor in the building
    	ask buildings{
    		if myself.t3_odd = self.name{
    			if myself.t3_odd = myself.residence{
    				myself.the_target <- myself.home_geom;
    			}else{
    				float the_target_z <-  float(rnd(0, self.bui_floor) * 4);
    				myself.the_target <- {myself.the_target.x, myself.the_target.y, the_target_z};
    			}
    		}
    	} 		
    }
    
    
    // Action that allows the students to do the task 4 in odd days
    //Based at the beginning in the following tutorial: https://gama-platform.github.io/wiki/RoadTrafficModel_step3
    reflex time_to_task4_odd when: (not even(current_date.day) and (current_date.minute_of_day = t4_t_odd) and (in_lockdown = false) and (is_responsible = false)){
    	objective <- "t4_odd";
    	the_target <- any_point_in (one_of(buildings where (each.name=t4_odd)));
    	
    	//allow the students to go to a random floor in the building
    	ask buildings{
    		if myself.t4_odd = self.name{
    			if myself.t4_odd = myself.residence{
    				myself.the_target <- myself.home_geom;
    			}else{
    				float the_target_z <-  float(rnd(0, self.bui_floor) * 4);
    				myself.the_target <- {myself.the_target.x, myself.the_target.y, the_target_z};
    			}
    		}
    	} 		
    }
    
    
    // Action that allows the students to go back home in odd days
    //THANKS TO https://gama-platform.github.io/wiki/RoadTrafficModel_step3
    reflex time_to_home_odd when: (not even(current_date.day) and (current_date.minute_of_day = home_t_o) and (in_lockdown = false) and (is_responsible = false)){
    	the_target <- home_geom;
    	objective <- "start_even_days" ;
    }
    
    
    
    // Reflex to reset the objective at the end of the day
    reflex reset_objective_midnight_odd when: (not even(current_date.day) and current_date.minute_of_day = 1430){
    	objective <- "start_even_days";
    }
    


	// REFLEX FOR THE MOVEMENTS OF THE STUDENTS
  	
    // Action that allows the movement of the students depending on the task and time
    //THANKS TO https://gama-platform.github.io/wiki/RoadTrafficModel_step3
    reflex move_to_task when: the_target != nil {
    	do goto target: the_target on: sidewalks_network speed: speed_to_task;
    	// The probability to be infected when using the footpaths is linked to the value given by the user at the beginning of the simulation (beta outdoor).
    	beta <- beta_outdoor;
    	
    	if the_target = location {
        	the_target <- nil ;

    	}
    } 

	// move the agents back to their original location to 'sleep' during the night.
	reflex go_to_room when:current_date.minute_of_day between(1215, 1230) and is_responsible = false{
    	do goto target: home_geom speed: speed_to_task;
    }  
    
    

    // EPIDEMIOLOGY EVOLUTION FOR THE AGENTS
    
    // Convert Susceptible to Exposed when infected by a Student
    action S_to_E_students {
    	is_exposed <- true;
        is_susceptible <- false;    	
    	//local coordinates where agent was infected 
    	infected_x_local <- self.location.x;
    	infected_y_local <- self.location.y;
    	infected_z_local <- self.location.z;
    	//generate a geometry in the correct EPSG code (27700)
    	geometry var1 <- {infected_x_local, infected_y_local, self.location.z}  CRS_transform("EPSG:27700");
    	//coordinates where agents where infected in the EPSG 27700
    	infected_x <- var1.location.x;
    	infected_y <- var1.location.y;
    	infected_z <- var1.location.z;
    	// gives the minute of the day in which the agent was infected
    	exposed_minute <- current_date.minute_of_day;
    	exposed_day <- current_date.day_of_year;
    }
    

    // Convert S to E from 'Students' to 'Students'
    reflex from_S_to_E_students_to_students when: is_infected{
        ask students at_distance 2 #m {
        	if (self.is_susceptible){
        		self.infective_contact_counter <- self.infective_contact_counter + 1;
        		if flip(myself.beta * (1 - (self.people_mask_efficiency/100)) * (1 - (myself.people_mask_efficiency/100))) {
	                self.infected_by <- myself.id;
	                do S_to_E_students;
            	}
        	}
            
        }
    }
    
    
    // Convert S to E from 'Students' to 'Dynamics'
    reflex from_S_to_E_students_to_dynamics when: is_infected{
        ask dynamics at_distance 2 #m {
        	if (self.is_susceptible){
        		self.infective_contact_counter <- self.infective_contact_counter + 1;
        		if flip(myself.beta * (1 - (self.people_mask_efficiency/100)) * (1 - (myself.people_mask_efficiency/100))) {
	                self.infected_by <- myself.id;
	                do S_to_E_dynamics;
            	}
        	}
            
        }
    }
    
    
    // Convert S to E from 'Students' to 'Statics'
    reflex from_S_to_E_students_to_statics when: is_infected{
        ask statics at_distance 2 #m {
        	if (self.is_susceptible){
        		self.infective_contact_counter <- self.infective_contact_counter + 1;
        		if flip(myself.beta * (1 - (myself.people_mask_efficiency/100))) {
	                self.infected_by <- myself.id; 
	                do S_to_I_statics;
            	}
        	}
        }
    }
    
    
    // Action to create contaminated elements by 'Students'
    action contaminated_elements_students{
    	
    	create species(statics) number: 1{
            location <- {myself.location.x, myself.location.y, myself.location.z};
            name <- 'Static_contaminated_object';
            type <- 'Static';
            nb_contaminated_elements <- nb_contaminated_elements + 1;
            id <- 'CE' + myself.id + '_' + nb_contaminated_elements;
            is_susceptible <- false;
            is_exposed <- false;
            is_infected <- true;
            is_recovered <- false;
            infective_minute <- current_date.minute_of_day;
            infective_day <- current_date.day_of_year (day_of_year-1);
            infected_by <- myself.id;
            //local coordinates where agent was infected 
            product_infected_x <- myself.location.x;
            product_infected_y <- myself.location.y;
            product_infected_z <- myself.location.z;
	    	//generate a geometry in the correct EPSG code (27700)
	    	geometry var2 <- {product_infected_x, product_infected_y, product_infected_z}  CRS_transform("EPSG:27700");
	    	//coordinates where agents where infected in the EPSG 27700
	    	infected_x <- var2.location.x;
	    	infected_y <- var2.location.y;
	    	infected_z <- var2.location.z;
            the_target <- nil;
        }
    }
    
    // transform students from Exposed to Infective once the incubation period (ro) has finished
    reflex from_E_to_I_students when: is_exposed and (current_date.day_of_year - exposed_day = ro) and (current_date.minute_of_day - exposed_minute = 0){
    	is_infected <- true;
    	is_exposed <- false;
    	infective_minute <- current_date.minute_of_day;
        infective_day <- current_date.day_of_year;
        
        //If the students is responsible, he/she will go home to be isolated (home_basement to be away from susceptible)
        if (day_of_simulation >= first_day_responsible){
        	if flip(percentage_people_responsible/100){
        		is_responsible <- true;
        		home_basement <- {home_geom.x, home_geom.y, -4};
        		the_target <- home_basement;
        	}
        }
	}
	
	// The students is free to continue his/her life. From this point he/she will start doing the daily routines
	reflex resposible_recovered_student when: is_responsible and is_recovered {
    	is_responsible <- false;
    }
    
    
    //Generate some contaminated objects in the locating where an infected person is located, based on the probability value of contaminated_object_probability
	//https://gama-platform.github.io/wiki/PredatorPrey_step6
	reflex contaminated_objects_students when: is_infected and flip(contaminated_object_probability) and (current_date.minute_of_day between(480, 1230) and (is_responsible = false)){
		do contaminated_elements_students;
	}   
	
	
	// Convert students from infective to recovered.
    reflex from_I_to_R_students when: is_infected and (current_date.day_of_year - infective_day = gamma) and (current_date.minute_of_day - infective_minute = 0) {
		is_infected <- false;
		is_recovered <- true;	
	}
}





species background {
	
	aspect base {
        draw shape color: #black +100;
    }
}







//DEFINE THE EXPERIMENTS:
experiment SIMULATION type: gui {
	//// Parameters that the user can change when using the simulation
	parameter "Buildings Shapefile:" var: shape_file_buildings category: "GIS data";
	parameter "Buildings without interaction Shapefile:" var: shape_file_buildings_no_interaction category: "GIS data";
	parameter "Students Shapefile:" var: shape_file_students category: "GIS data";
	parameter "Dynamics Shapefile:" var: shape_file_dynamics category: "GIS data";
	parameter "Statics Shapefile:" var: shape_file_statics category: "GIS data";
	parameter "Roads Shapefile:" var: shape_file_sidewalks category: "GIS data" ;
	parameter "Boundary Shapefile:" var: shape_file_bounds category: "GIS data" ;

	
	//EPIDEMIOLOGY PARAMETERS
	parameter "Number of initial Infected students:" var: students_I_initial init: 2 min:0 max:20 step: 1 category: "Epidemiology parameters";
	parameter "Number of initial Infected dynamics:" var: dynamics_I_initial init: 0 min:0 max:20 step: 1 category: "Epidemiology parameters";
	parameter "Number of initial Infected statics:" var: statics_I_initial init: 0 min:0 max:20 step: 1 category: "Epidemiology parameters";
	parameter "Probability to be infected indoor (beta_indoor)" var: beta_indoor init: 0.025 min:0.0 max: 1.0 step: 0.005 category: "Epidemiology parameters"; 
	parameter "Probability to be infected outdoor (beta_outdoor)" var: beta_outdoor init: 0.005 min:0.000 max: 1.000 step: 0.005 category: "Epidemiology parameters"; 
	parameter "Incubation period (ro)" var: ro init: 5 min:0 max: 10 step: 1 category: "Epidemiology parameters"; 
	parameter "Contagious period (gamma)" var: gamma init: 7 min:1 max: 15 step: 1 category: "Epidemiology parameters";
	
	
	
	//FACE MASKS PARAMETERS
	parameter "% of people (students and dynamics) using face masks" var:percentage_people_with_mask init: 20 min: 0 max: 100 step: 5 category: "Face masks parameters";
	parameter "First day to start using face masks" var: first_day_with_mask init: 15 min: 0 max: 100 step: 1 category: "Face masks parameters";
	parameter "Face masks efficiency" var: percentage_mask_efficiency init: 50 min: 0 max: 100 step: 5 category: "Face masks parameters";
	
	
	//LOCKDOWN PARAMETERS
	parameter "% of students in lockdown" var:percentage_students_lockdown init: 40 min: 0 max: 100 step: 5 category: "Lockdown parameters";
	parameter "First day in lockdown" var:first_day_lockdown init: 10 min: 0 max: 100 step: 5 category: "Lockdown parameters";
	
	//RESPONSIBLE STUDENTS PARAMETERS
	parameter "First day self isolation" var: first_day_responsible init: 10 min: 0 max: 100 step: 1 category: "Responsability parameters";
	parameter "% of students doing self isolation" var:percentage_people_responsible init: 40 min: 0 max: 100 step: 5 category: "Responsability parameters";
	
	
	

    output {
        
		// map with the buildings, roads and people
        display map_3D type: opengl {  
            
            species students aspect: sphere3D ; 
            species dynamics aspect: sphere3D ;  
            species statics aspect: sphere3D ;        
            species buildings aspect: base transparency: 0.8;
            species buildings_without_interaction aspect: base transparency: 0.8;
            species background aspect: base;
            species sidewalks aspect: base;
        }
        
        // labels showing the different values in real time
         
        monitor "Day" value: (current_date.day_of_year - (day_of_year-1));
        monitor "Susceptible students" value: nb_S_students;
        monitor "Exposed students" value: nb_E_students;
		monitor "Infective students" value: nb_I_students;
		monitor "Recovered students" value: nb_R_students;
		monitor "TOTAL STUDENTS" value: total_students;  //this value shows the number Students or dynamic agents only.
		
        monitor "Susceptible dynamics" value: nb_S_dynamics;
        monitor "Exposed dynamics" value: nb_E_dynamics;
		monitor "Infective dynamics" value: nb_I_dynamics;
		monitor "Recovered dynamics" value: nb_R_dynamics;
		monitor "TOTAL DYNAMICS" value: total_dynamics;  //this value shows the number Students or dynamic agents only.

		monitor "Susceptible statics" value: nb_S_statics;
		monitor "Infective statics" value: nb_I_statics;
		monitor "TOTAL STATICS" value: total_statics;  //this value shows the number Students or dynamic agents only.
		
		monitor "TOTAL AGENTS" value: total_students + total_dynamics + total_statics;
		
		monitor "Active contaminated elements" value: contaminated_elements;
		//monitor "Reproductive Number R" value: R with_precision 1;
    }
}



